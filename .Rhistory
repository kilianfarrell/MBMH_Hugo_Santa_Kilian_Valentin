return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile,)
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile)
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile, use.names = FALSE)
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile, use.names = FALSE)
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile, use.names = FALSE)
# c'est moche mais ça marche
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile)
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile, use.names = FALSE)
# c'est moche mais ça marche
beta_chap_etoile_final = c('a_chap_etoile' = beta_chap_etoile_final$a_chap_etoile,
'b_chap_etoile' = beta_chap_etoile_final$b_chap_etoile,
'c_chap_etoile' = beta_chap_etoile_final$c_chap_etoile)
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c('a_chap_etoile' = a_chap_etoile,
'b_chap_etoile' = b_chap_etoile,
'c_chap_etoile' = c_chap_etoile, use.names = FALSE)
# c'est moche mais ça marche
beta_chap_etoile_final = c('a_chap_etoile' = beta_chap_etoile_final['a_chap_etoile'],
'b_chap_etoile' = beta_chap_etoile_final['b_chap_etoile'],
'c_chap_etoile' = beta_chap_etoile_final['c_chap_etoile'])
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c(a_chap_etoile, b_chap_etoile, c_chap_etoile, use.names = FALSE)
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c(a_chap_etoile, b_chap_etoile, c_chap_etoile, use.names = FALSE)
rownames(beta_chap_etoile_final) = c('a_chap_etoile', 'b_chap_etoile', 'c_chap_etoile')
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c(a_chap_etoile, b_chap_etoile, c_chap_etoile, use.names = FALSE)
print(beta_chap_etoile_final)
rownames(beta_chap_etoile_final) = c('a_chap_etoile', 'b_chap_etoile', 'c_chap_etoile')
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
# faire un fonction pour c par bootstrap
sim_ab_etoile_replicate = function(reg_M, reg_Y){ # ici pour un replicate
# calcul des de M etoile
residus_chap_M = c(reg_M$residuals, use.names = FALSE)
n = length(residus_chap_M)
beta_chap_M = summary(reg_M)$coef[,'Estimate']
X_M = cbind(1, as.matrix(data[,c('X_tilde')]))
residus_etoile_M = sample(residus_chap_M, n, replace = TRUE)
M_etoile = c(X_M%*%beta_chap_M) + residus_etoile_M
# calcul des de Y etoile
residus_chap_Y = c(reg_Y$residuals, use.names = FALSE)
n = length(residus_chap_Y)
beta_chap_Y = summary(reg_Y)$coef[,'Estimate']
X_Y = cbind(1, as.matrix(data[,c('X_tilde', 'M')]))
residus_etoile_Y = sample(residus_chap_Y, n, replace = TRUE)
Y_etoile = c(X_Y%*%beta_chap_Y) + residus_etoile_Y
# calcul des estim par MCO
a_chap_etoile = lm(M_etoile ~ data$X_tilde)$coef[-1]
beta_chap_etoile = lm(Y_etoile ~ data$X_tilde + data$M)$coef[-1]
b_chap_etoile = beta_chap_etoile['data$M']
c_chap_etoile = beta_chap_etoile['data$X_tilde']
beta_chap_etoile_final = c(a_chap_etoile, b_chap_etoile, c_chap_etoile, use.names = FALSE)
print(beta_chap_etoile_final)
names(beta_chap_etoile_final) = c('a_chap_etoile', 'b_chap_etoile', 'c_chap_etoile')
return(beta_chap_etoile_final) # faudrait donner des noms au lignes
}
replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y))
t(replicate(10, sim_ab_etoile_replicate(reg_M, reg_Y)))
setwd('C:/Users/hugob/TP_M2/methode bayesienne/birats')
N <-30
T <-5
y <-structure(c(151, 145, 147, 155, 135, 159, 141, 159, 177, 134,
160, 143, 154, 171, 163, 160, 142, 156, 157, 152, 154, 139, 146,
157, 132, 160, 169, 157, 137, 153, 199, 199, 214, 200, 188, 210,
189, 201, 236, 182, 208, 188, 200, 221, 216, 207, 187, 203, 212,
203, 205, 190, 191, 211, 185, 207, 216, 205, 180, 200, 246, 249,
263, 237, 230, 252, 231, 248, 285, 220, 261, 220, 244, 270, 242,
248, 234, 243, 259, 246, 253, 225, 229, 250, 237, 257, 261, 248,
219, 244, 283, 293, 312, 272, 280, 298, 275, 297, 350, 260, 313,
273, 289, 326, 281, 288, 280, 283, 307, 286, 298, 267, 272, 285,
286, 303, 295, 289, 258, 286, 320, 354, 328, 297, 323, 331, 305,
338, 376, 296, 352, 314, 325, 358, 312, 324, 316, 317, 336, 321,
334, 302, 302, 323, 331, 345, 333, 316, 291, 324), .Dim = c(30,
5))
x <- c(8.0, 15.0, 22.0, 29.0, 36.0)
xbar <- 22
Omega <- structure(c(0.005, 0, 0, 5), .Dim = c(2, 2))
y
is.matrix(y)
rep(1:30, each = 5)
rep(x, 30)
matrix('i' = rep(1:30, each = 5), # each = 5 pour les 5 x_j possible
'x_j' = rep(x, 30), # 30 fois la séquence des 5 x_j
'y_ij' = y,
ncol = 3, nrow = 30*5)
y
c(y)
data = matrix('i' = rep(1:30, each = 5), # each = 5 pour les 5 x_j possible
'x_j' = rep(x, 30), # 30 fois la séquence des 5 x_j
'y_ij' = c(y),
ncol = 3, nrow = 30*5)
data = matrix(c('i' = rep(1:30, each = 5), # each = 5 pour les 5 x_j possible
'x_j' = rep(x, 30), # 30 fois la séquence des 5 x_j
'y_ij' = c(y)),
ncol = 3, nrow = 30*5)
data
View(data)
sapply(1:30, \(i){y[i,]})
c(sapply(1:30, \(i){y[i,]}))
t(y)
c(t(y))
y
data = matrix(c('i' = rep(1:30, each = 5), # each = 5 pour les 5 x_j possible
'x_j' = rep(x, 30), # 30 fois la séquence des 5 x_j
'y_ij' = c(t(y)) ),# transformation car c() prend colonne par colonne
ncol = 3, nrow = 30*5, colnames = c('i', 'x_j', 'y_ij'))
data = matrix(c('i' = rep(1:30, each = 5), # each = 5 pour les 5 x_j possible
'x_j' = rep(x, 30), # 30 fois la séquence des 5 x_j
'y_ij' = c(t(y)) ),# transformation car c() prend colonne par colonne
ncol = 3, nrow = 30*5, dimnames = list(c('i', 'x_j', 'y_ij')))
data = matrix(c('i' = rep(1:30, each = 5), # each = 5 pour les 5 x_j possible
'x_j' = rep(x, 30), # 30 fois la séquence des 5 x_j
'y_ij' = c(t(y)) ),# transformation car c() prend colonne par colonne
ncol = 3, nrow = 30*5, dimnames = list(c('i', 'x_j', 'y_ij')), )
data = matrix(c('i' = rep(1:30, each = 5), # each = 5 pour les 5 x_j possible
'x_j' = rep(x, 30), # 30 fois la séquence des 5 x_j
'y_ij' = c(t(y)) ),# transformation car c() prend colonne par colonne
ncol = 3, nrow = 30*5)
colnames(data) = c('i', 'x_j', 'y_ij')
library(coda)
post <- read.csv(file = 'samples.csv', header = TRUE, comment.char = '#')
beginwith <- function(vstr, patterns) {
patterns <- paste(patterns, ".*", sep = '');
a <- lapply(patterns, FUN = function(p) {grep(p, vstr)})
do.call("c", a)
}
sigma_beta <- post[, beginwith(colnames(post), "Sigma_beta\\.")]
N <-
30
T <-
5
y <-
structure(c(151, 145, 147, 155, 135, 159, 141, 159, 177, 134,
160, 143, 154, 171, 163, 160, 142, 156, 157, 152, 154, 139, 146,
157, 132, 160, 169, 157, 137, 153, 199, 199, 214, 200, 188, 210,
189, 201, 236, 182, 208, 188, 200, 221, 216, 207, 187, 203, 212,
203, 205, 190, 191, 211, 185, 207, 216, 205, 180, 200, 246, 249,
263, 237, 230, 252, 231, 248, 285, 220, 261, 220, 244, 270, 242,
248, 234, 243, 259, 246, 253, 225, 229, 250, 237, 257, 261, 248,
219, 244, 283, 293, 312, 272, 280, 298, 275, 297, 350, 260, 313,
273, 289, 326, 281, 288, 280, 283, 307, 286, 298, 267, 272, 285,
286, 303, 295, 289, 258, 286, 320, 354, 328, 297, 323, 331, 305,
338, 376, 296, 352, 314, 325, 358, 312, 324, 316, 317, 336, 321,
334, 302, 302, 323, 331, 345, 333, 316, 291, 324), .Dim = c(30,
5))
x <-
c(8.0, 15.0, 22.0, 29.0, 36.0)
xbar <-
22.0
y
y <- structure(c(151, 145, 147, 155, 135, 159, 141, 159, 177, 134,
160, 143, 154, 171, 163, 160, 142, 156, 157, 152, 154, 139, 146,
157, 132, 160, 169, 157, 137, 153, 199, 199, 214, 200, 188, 210,
189, 201, 236, 182, 208, 188, 200, 221, 216, 207, 187, 203, 212,
203, 205, 190, 191, 211, 185, 207, 216, 205, 180, 200, 246, 249,
263, 237, 230, 252, 231, 248, 285, 220, 261, 220, 244, 270, 242,
248, 234, 243, 259, 246, 253, 225, 229, 250, 237, 257, 261, 248,
219, 244, 283, 293, 312, 272, 280, 298, 275, 297, 350, 260, 313,
273, 289, 326, 281, 288, 280, 283, 307, 286, 298, 267, 272, 285,
286, 303, 295, 289, 258, 286, 320, 354, 328, 297, 323, 331, 305,
338, 376, 296, 352, 314, 325, 358, 312, 324, 316, 317, 336, 321,
334, 302, 302, 323, 331, 345, 333, 316, 291, 324), .Dim = c(30,
5))
y2 <-
structure(c(151, 145, 147, 155, 135, 159, 141, 159, 177, 134,
160, 143, 154, 171, 163, 160, 142, 156, 157, 152, 154, 139, 146,
157, 132, 160, 169, 157, 137, 153, 199, 199, 214, 200, 188, 210,
189, 201, 236, 182, 208, 188, 200, 221, 216, 207, 187, 203, 212,
203, 205, 190, 191, 211, 185, 207, 216, 205, 180, 200, 246, 249,
263, 237, 230, 252, 231, 248, 285, 220, 261, 220, 244, 270, 242,
248, 234, 243, 259, 246, 253, 225, 229, 250, 237, 257, 261, 248,
219, 244, 283, 293, 312, 272, 280, 298, 275, 297, 350, 260, 313,
273, 289, 326, 281, 288, 280, 283, 307, 286, 298, 267, 272, 285,
286, 303, 295, 289, 258, 286, 320, 354, 328, 297, 323, 331, 305,
338, 376, 296, 352, 314, 325, 358, 312, 324, 316, 317, 336, 321,
334, 302, 302, 323, 331, 345, 333, 316, 291, 324), .Dim = c(30,
5))
y == y2
alpha <- c(250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250)
library(coda)
library(invgamma)
library(MASS)
library(gtools)
library(matlib)
library(Matrix)
# data
source("schools.data.R")
setwd("~/")
setwd("C:/Users/hugob/TP_M2/methode bayesienne/schools/MBMH_Hugo_Santa_Kilian_Valentin")
# data
source("schools.data.R")
View(R)
View(R)
datadf = cbind(data.frame(Y,school,Gender,LRT),School_gender,School_denom,VR)
colnames(datadf) = c("Y","school","Gender","LRT","School_gender1","School_gender2","School_denom1",
"School_denom2","School_denom3","VR1","VR2")
View(datadf)
theta = rnorm(1, sd = 10**2)
phi = rnorm(1, sd = 10**2)
gamma = rnorm(3, sd = 10**2)
beta = rnorm(8, sd = 10**2)
T = rWishart(1, df = 3, Sigma = R)[,,1]
T
nb_in_school_j = sum(datadf[,'school'] == j)
j = 1
nb_in_school_j = sum(datadf[,'school'] == j)
invT = inv(T)
invT
T
invT[1,1]
matrix(invT[1,-1], ncol=2, nrow = 1)
T[-1,-1]
matrix(invT[-1,1], ncol = 1, nrow = 2)
sigma2_prior_alpha1j = invT[1,1] - matrix(invT[1,-1], ncol=2, nrow = 1)%*%T[-1,-1]%*%matrix(invT[-1,1], ncol = 1, nrow = 2) #<- variance négative
sigma2_prior_alpha1j
T = rWishart(1, df = 3, Sigma = inv(R))[,,1]
T = rWishart(1, df = 3, Sigma = inv(R))[,,1]
T
invT = inv(T)
invT
invT[1,1]
matrix(invT[1,-1], ncol=2, nrow = 1)
T[-1,-1]
T
matrix(invT[-1,1], ncol = 1, nrow = 2)
matrix(invT[1,-1], ncol=2, nrow = 1)%*%T[-1,-1]%*%matrix(invT[-1,1], ncol = 1, nrow = 2)
invT[1,1]
T = rWishart(1, df = 3, Sigma = R)[,,1]
T
T = structure(c(10, -3, -3, -3, 135, -65, -3, -65, 135), .Dim = as.integer(c(3,
3)))
T
invT = inv(T)
invT
invT[1,1]
matrix(invT[1,-1], ncol=2, nrow = 1)%*%T[-1,-1]%*%matrix(invT[-1,1], ncol = 1, nrow = 2)
invT[1,1] - matrix(invT[1,-1], ncol=2, nrow = 1)%*%T[-1,-1]%*%matrix(invT[-1,1], ncol = 1, nrow = 2)
theta = rnorm(1, sd = 10**2)
phi = rnorm(1, sd = 10**2)
gamma = rnorm(3, sd = 10**2)
beta = rnorm(8, sd = 10**2)
alpha = mvrnorm(38, mu = gamma, Sigma = T)
init = c(theta, phi, gamma, beta, T, alpha)
N_chain = 10
chain = matrix(NA, N_chain + 1, ncol = 136)
colnames(chain) = c('theta',
'phi',
paste0('gamma_', 1:3),
paste0('beta_', 1:8),
paste0('T_1_', 1:3), # attention, rempli par ligne
paste0('T_2_', 1:3),
paste0('T_3_', 1:3),
paste0('alpha_1_', 1:38),# attention, rempli par ligne
paste0('alpha_2_', 1:38),
paste0('alpha_3_', 1:38))
# init de
chain[1,] = init
chain
i = 2
# remise en forme
theta = chain[i-1,1]
phi = chain[i-1,2]
gamma = chain[i-1,3:5]
beta = chain[i-1,6:13]
T = matrix(chain[i-1,14:22], ncol = 3, nrow = 3, byrow = TRUE)
alpha = matrix(chain[i-1,23:136], ncol = M, nrow = 3, byrow = TRUE)
T
## maj de gamma
Sigma_gamma_star = inv(M*T + diag(10**4, ncol = 3, nrow = 3))
Mu_gamma_star = Sigma_gamma_star%*%(T%*%rowSums(alpha)) # moy de gamma0 c'est 0
gamma = mvrnorm(1, Mu_gamma_star, Sigma_gamma_star)
gamma
## maj de T
somme = matrix(0,9,nrow=3,ncol=3)
for (j in 1:M){
a_m_g_j = alpha[,j] - gamma
somme = somme + tcrossprod(a_m_g_j)
}
V = inv(somme + inv(R))
T = rWishart(1, df = M+2, Sigma = V)[,,1]
T
invT = inv(T)
invT
matrix(invT[1,-1], ncol=2, nrow = 1)%*%T[-1,-1]%*%matrix(invT[-1,1], ncol = 1, nrow = 2)
